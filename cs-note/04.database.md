# CHAPTER 4. 데이터베이스

## SECTION 4.1 데이터베이스의 기본

> **데이터베이스 (DB, DataBase)**
> - 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터 모음
> - 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행
> - 실시간 접근과 동시 공유 가능
> **DBMS (DataBase Management System)**
> - 데이터베이스를 제어, 관리하는 통합 시스템

### 4.1.1 엔티티 (Entity)

- **사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사**
- 서비스의 요구 사항에 맞춰 속성이 정해짐

#### 약한 엔티티와 강한 엔티티

- 약한 엔티티
    - 자신의 키 속성만으로는 엔티티를 고유하게 식별할 수 없는 타입
- 강한 엔티티
    - 자신의 키 속성만을 이용해서 고유하게 엔티티들을 식별할 수 있는 타입
- 약한 엔티티 vs. 강한 엔티티
- 
    |  | 약한 엔티티 | 강한 엔티티 |
    | --- | --- | --- |
    | 키 | 부분 식별자 키 | 기본 키 |
    | 의존 | 강한 엔티티에 의존 | 다른 엔티티와 독립적 |
    | 표시 | 이중 직사각형 | 단일 직사각형 |
    | 관계 | 약한 엔티티와 강한 엔티티 사이의 관계를 이중의 다이아몬트로 표시된 Identification Relationship으로 표시 | 두 개의 강한 엔티티 개체 사이의 관계를 단순히 Relationship이라고 하는 단일 다이아몬드로 표시 |
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b0534c19-fbab-4715-8249-f93a85ff5364/Untitled.png)


### 4.1.2 릴레이션 (Relation)

- **데이터베이스에서 정보를 구분하여 저장하는 기본 단위**
- 엔티티에 관한 데이터를 하나의 릴레이션에 담아서 관리
- 관계형 데이터베이스에서는 **테이블**이라고 하고, NoSQL 데이터베이스에서는 **컬렉션**이라고 함

### 4.1.3 속성 (Attribute)

- **릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보**

### 4.1.4 도메인 (Domain)

- **릴레이션이 포함된 각각의 속성들이 가질 수 있는 값의 집합**

### 4.1.5 필드와 레코드

- **필드 (Field)**
    - 각 속성 영역의 **열(Column)**
    - <b>어트리뷰트(Attribute), 칼럼(Column)</b>이라고도 함
- **레코드 (Record)**
    - 테이블이 쌓이는 **행(Row)**
    - <b>튜플(Tuple)</b>이라고도 함

### 필드 타입

- **숫자 타입**
    - **TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 등**

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b0f4cd9-0b49-4e4d-99d1-1d5bb5eceba2/Untitled.png)

- **날짜 타입**
    - **DATE, DATETIME, TIMESTAMP 등**

  |  | DATE | DATETIME | TIMESTAMP |
      | --- | --- | --- | --- |
  | 정의 | 날짜 부분은 있지만 시간 부분은 없는 값 | 날짜 및 시간 부분을 모두 포함하는 값 | 날짜 및 시간 부분을 모두 포함하는 값 |
  | 범위 | 1000-01-01 ~ 9999-12-31 | 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 | 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07 |
  | 용량 | 3바이트 | 8바이트 | 4바이트 |
- **문자 타입**
    - **CHAR, VARCHAR, TEXT, BLOB, ENUM, SET 등**
    - CHAR vs. VARCHAR

        |  | CHAR | VARCHAR |
        | --- | --- | --- |
        | 길이 고정 | 테이블 생성 시 선언한 길이로 고정 | 입력된 데이터에 따라 용량을 가변시켜 저장 (가변 길이 문자열) |
        | 길이 | 0 ~ 255 | 0 ~ 65,535 |
        | 사용하는 경우 (효율이 더 좋은 경우) | 유동적이지 않는 길이의 데이터 | 유동적인 길이를 가지는 데이터 |

    - TEXT
        - 큰 문자열 저장에 사용
        - 주로 게시판 본문 저장에 씀
    - BLOB
        - 이미지, 동영상 등 큰 데이터 저장 시 사용
        - 참고 ) 보통 스토리지에 파일을 올리고 파일 경로를 VARCHAR로 저장함
    - ENUM
        - 하나만 선택하는 단일 선택만 가능
        - ENUM 리스트에 없는 잘못된 값 삽입 시 빈 문자열이 대신 삽입됨
        - 메모리를 적게 사용
        - 최대 65,535개 요소를 넣을 수 있음
    - SET
        - 여러 개의 데이터 선택 가능
        - 비트 단위 연산
        - 최대 64개 요소를 넣을 수 있음

### 4.1.6 관계

- 여러 테이블의 관계를 의미하며, 관계 화살표로 나타냄

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f5b219d5-39c8-4c17-9db2-b56501fed6c3/Untitled.png)


#### 1:1 관계

- **두 엔티티가 반드시 하나의 관계를 가짐**

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1fd506af-5dbd-451e-999f-d7fc9cc40768/Untitled.png)


#### 1:N 관계

- **한 엔티티가 다른 많은 엔티티를 포함하는 관계**

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/07329b9b-e7a4-4b65-910b-6ec179e6cdfd/Untitled.png)


#### N:M 관계

- **양쪽 엔티티 모두 서로 다른 많은 엔티티를 포함할 수 있는 관계**
- N:M은 테이블 두 개를 직접적으로 연결해서 구축하지 않고 1:N, 1:M 이라는 관계를 갖는 두 개의 테이블로 나눠 설정함

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/86799894-f54e-4c25-b23c-859316c8e9b8/Untitled.png)


### 4.1.7 키

- 테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 설정하기 위한 장치
- **기본키, 외래키, 후보키, 슈퍼키, 대체키**가 있음

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31bd7edf-42a5-416e-b737-eb63b5dba564/Untitled.png)


#### 기본키 (Primary Key)

- **PK** 또는 **프라이머리키**라고 부름
- **유일성**과 **최소성**을 만족하는 키
- **고유하게 존재하는 속성**
- **중복되어서는 안됨**
- 자연키
    - 언젠가는 변하는 키
- 인조키
    - 인워적으로 생성하여 변하지 않는 키
    - 보통 기본키는 인조키로 설정

#### 외래키 (Foreign Key)

- **FK** 라고도 부름
- **다른 테이블의 기본키를 그대로 참조하는 값**
- 개체와의 관계 식별에 사용
- **중복되어도 괜찮음**

#### 후보키 (Candidate Key)

- **기본키가 될 수 있는 후보들**
- 유일성과 최소성을 동시에 만족하는 키

#### 대체키 (Alternate Key)

- **후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키**

#### 슈퍼키 (Super Key)

- **각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키**

## SECTION 4.2 ERD와 정규화 과정

### 4.2.1 ERD의 중요성

- **ERD (Entity Relationship Diagram)**
    - 시스템의 요구사항을 기반으로 작성됨
    - **데이터베이스를 구축할 때 가장 기초적인 뼈대 역할**
    - 릴레이션 간의 관계들을 정의한 것
    - **설계도 역할**
- ERD는 **관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용**할 수 있지만 **비정형 데이터를 충분히 표현할 수 없다**는 단점이 있음

### 4.2.2 예제로 배우는 ERD

#### 승원 영업부서의 ERD

- 요구사항
    - 영엽사원은 0 ~ n 명의 고객을 관리함
    - 고객은 0 ~ n개의 주문을 넣을 수 있음
    - 주문은 1 ~ n개의 상품이 들어감
- 정답

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0296b9ff-81f9-4fa5-be30-9d2a0e84b0b3/Untitled.png)


#### 무무오브레전드의 ERD

- 요구사항
    - 선수들은 1명의 챔피언을 고를 수 있음
    - 챔피언은 한 개 이상의 스킬을 가짐
    - 스킬은 한 개 이상의 특성을 가짐
- 정답

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d339d7b1-1f62-46cc-921c-ce22aadcf4bf/Untitled.png)


### 4.2.3 정규화 과정

- 릴레이션 간의 잘못된 종속 관계로 인해 **데이터베이스 이상 현상이 일어나서 이를 해결**하거나 **저장공간의 효율적으로 사용하기 위해** **릴레이션을 여러 개로 분리하는 과정**

    <pre>
    <b>데이터베이스 이상 현상</b>
    - 삽입 이상 : 특정 데이터가 존재하지 않아 중요한 데이터를 데이터베이스에 삽입할 수 없는 현상
    - 삭제 이상 : 특정 데이터 삭제 시 원치 않은 다른 데이터도 삭제되는 현상
    - 조회 이상 : 특정 데이터 업데이트 시 정상적으로 변경되지 않거나 너무 많은 데이터가 업데이트 되는 현상
    </pre>

- 정규형 원칙을 기반으로 정규형을 만들어가는 과정

    <pre>
    <b>정규형(NF, Normal Form)</b>
    -정규화된 정도
    </pre>

- 기본 정규형
    - 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형
- 고급 정규형
    - 제4정규형, 제5정규형

#### 정규형 원칙

- 자료의 중복성 감소
- 독립적인 관계는 별개의 릴레이션으로 표현
- 각각의 릴레이션은 독립적인 표현이 가능해야 함

#### 제1정규형

- **릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값으로만 구성**
- 반복 집합이 있다면 제거해야 함

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d32e7556-f2d1-45b1-b052-f785ed89f818/Untitled.png)


#### 제2정규형

- **릴레이션이 제1정규형이며 부분 함수의 종속성을 제거한 형태**

    <pre>
    <b>부분 함수의 종속성</b>
    - 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것
    </pre>

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/480e4617-0ada-4e15-9f10-2a8cf0d6d118/Untitled.png)

- **동등한 릴레이션으로 분해해야 하고 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 함**

#### 제3정규형

- **제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태**

    <pre>
    <b>이행적 함수 종속 (transitive FD)</b>
    - A → B와 B → C가 존재하면 논리적으로 A → C 성립
    </pre>

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/543f36fc-bc8d-4ece-8238-8e4da4594de9/Untitled.png)


#### 보이스/코드 정규형 (BCNF)

- **제3정규형이고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결장자가 후보키인 상태**

    <pre>
    <b>결정자</b>
    - 함수 종속 관계에서 특정 종속자를 결정짓는 요소
    - X → Y일 때 X는 결정자, Y는 종속자
    </pre>

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a1fd0c5-23e3-46b0-85be-aee74eaadc19/Untitled.png)


#### 정규형을 하면 무조건 성능이 좋아질까?

- 정규형 과정을 거쳐 테이블을 나눈다고 해서 **성능이 100% 좋아지는 것은 아님**
- 테이블을 나누게 되면 어떠한 쿼리는 **조인을 해야 하는 경우도 발생해서 오히려 느려질 수도 있음**
- 서비스에 따라 정규화 또는 비정규화 과정을 진행해야 함

## SECTION 4.3 트랜잭션과 무결성

### 4.3.1 트랜잭션

- **데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위**
- 여러 개의 쿼리들을 하나로 묶는 단위
- 특징 : **ACID (원자성, 일관성, 독립성, 지속성)**

#### 원자성 (Atomicity)

- **트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징**
- 트랜잭션을 커밋했는데 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장하는 것

    <pre>
    <b>커밋 (Commit)</b>
    - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
    <b>롤백 (Rollback)</b>
    - 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일
    </pre>

- 트랜잭션 전파
    - 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것

#### 일관성 (Consistency)

- **허용된 방식으로만 데이터를 변경해야 하는 것**
- 여러 가지 조건, 규칙에 따라 유효함을 가져야 함

#### 격리성 (Isolation)

- **트랜잭션 수행 시 서로 끼어들지 못하는 것**
- **격리 수준**

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d60b4866-92aa-48e0-be32-f445bd66877a/Untitled.png)

    - **SERIALIZABLE**
        - **트랜잭션을 순차적으로 진행시키는 것**
        - 여러 트랜잭션이 동시에 같은 행에 접근할 수 없음
        - **매우 엄격한 수준의 격리**
        - 교착 상태가 일어날 확률도 많고 가장 성능이 떨어짐
    - **REPEATABLE_READ**
        - **하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행 추가는 막지 않음**
        - **이후에 추가된 행이 발견될 수도 있음**
        - **팬텀 리드 발생**
    - **READ_COMMITTED**
        - **가장 많이 사용되는 격리 수준**
        - MySQL 8.0, PostgreSQL, SQL Server, 오라클에서 기본값으로 설정
        - 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음
        - **커밋된 데이터에 대해서만 조회 허용**
        - **어떤 트랜잭션이 접근한 행을 다른 트랜잭션에서 수정 가능**
        - **팬텀 리드, 반복 가능하지 않은 조회 발생**
    - **READ_UNCOMMITTED**
        - **가장 낮은 격리 수준**
        - 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있음
        - **가장 빠름**
        - 거대한 양의 데이터를 **어림잡아** 집계하는 데 사용하면 좋음
        - **팬텀 리드, 반복 가능하지 않은 조회, 더티 리드 발생**
- **격리 수준에 따라 발생하는 현상**
    - 팬텀 리드 (Phantom Read)
        - 한 트랜잭션 내에서 **동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우**
    - 반복 가능하지 않은 조회 (Non-Repeatable Read)
        - 한 트랜잭션 내의 같은 행에 **두 번 이상 조회가 발생했는 데, 그 값이 다른 경우**
    - 더티 리드 (Dirty Read)
        - 반복 가능하지 않은 조회와 유사
        - 한 트랜잭션이 실행 중일 때 다른 트랜잭셔네 의해 수정되었지만 **아직 커밋되지 않은 행의 데이터를 읽을 수 있을 때 발생**

#### 지속성 (Durability)

- **성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것**
- 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능 필요
- 체크섬, 저널링 롤백 등의 기능 제공

    <pre>
    <b>체크섬</b>
    - 중복 검사의 한 형태
    - 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
    <b>저널링</b>
    - 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것
    - 트랜잭션 등 변경 사항에 대한 로그를 남기는 것
    </pre>


### 4.3.2 무결성

- **데이터의 정확성, 일관성, 유효성을 유지하는 것**
- 무결성이 유지되어야 데이터베이스에 신뢰가 생김
- 무결성 종류

    | 이름 | 설명 |
    | --- | --- |
    | 개체 무결성 | 기본키로 선택된 필드는 빈 값을 허용하지 않음 |
    | 참조 무결성 | 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함 |
    | 고유 무결성 | 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐 |
    | NULL 무결성 | 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건 |

## SECTION 4.4 데이터베이스 종류

### 4.4.1 관계형 데이터베이스 (RDBMS)

- **행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스**
- SQL이라는 언어를 써서 조작
- **MySQL, PostgreSQL, 오라클, SQL Server, MSSQL 등**
- 표준 SQL은 지키지만 각 제품에 특화된 SQL 사용

  ⇒ 오라클 : PL/SQL, SQL Server : T-SQL, MySQL : SQL


#### MySQL

- **대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스**
- C, C++로 만들어졌음
- **MyISAM 인덱스 압축 기술, B-트리 기반 인덱스, 스레드 기반 메모리 할당, 매우 빠른 조인, 최대 64개 인덱스 제공**
- 대용량 데이터베이스를 위해 설계되어 있음
- **롤백, 커밋, 이중 암호 지원 보안 등 기능 제공**
- MySQL 스토리지 엔진 아키텍처

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/adbbd0d7-b6db-46c6-b570-3126f9f81ba3/Untitled.png)

    - 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있음
    - 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점
    - 커넥션 API 및 서비스 계층을 통해 MySQL 데이터베이스와 쉽게 상호 작용 가능
    - 쿼리 캐시를 지원해 입력된 쿼리 문에 대한 전체 결과 집합을 저장

      ⇒ 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시


#### PostgreSQL

- MySQL 다음으로 선호하는 데이터베이스 기술로 널리 인정받고 있음
- **디스크 조각이 차지하는 영역을 회수할 수 있는 장치인 VACCUM이 있음**
- 최대 테이블 크기 : 32TB
- SQL 뿐만 아니라 **JSON을 이용해 데이터 접근 가능**
- **지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등 제공**

### 4.4.2 NoSQL 데이터베이스

- **SQL을 사용하지 않는 데이터베이스**
- **MongoDB, Redis 등**

#### MongoDB

- **JSON을 통해 데이터 접근**
- Binary JSON형태 (BJSON)로 데이터가 저장됨
- 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반 데이터베이스
- **확장성이 뛰어나고 빅데이터 저장 시 성능이 좋음**
- **고가용성, 샤딩, 레플리카셋 지원**
- 스키마를 정해 놓지 않고 데이터 삽입 가능

  → 다양한 도메인의 데이터베이스 기반으로 분석하거나 로깅 등을 구현할 때 강점

- 도큐먼트 생성 시 다른 컬렉션에 중복된 값을 지니기 힘든 **유니크한 값인 ObjectID**가 생성됨

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b016c34b-3396-484e-bd03-df3f0e0af770/Untitled.png)

    - 기본 키로 유닉스 시간 기반의 타임스탬프(4바이트), 랜덤 값(5바이트), 카운터(3바이트)로 이루어짐

#### Redis

- **인메모리 데이터베이스**
- **키-값 데이터 모델 기반**의 데이터베이스
- 기본적인 데이터 타입은 string이며, set, hash 등을 지원함
- 최대 512MB까지 저장 가능
- **pub/sub 기능을 통해 체팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐시 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋 자료 구조를 이용한 실시간 순위표 서비스에 사용**

## SECTION 4.5 인덱스

### 4.5.1 인덱스의 필요성

- **인덱스**
    - 데이터를 빠르게 찾을 수 있는 하나의 장치
- **인덱스를 설정하면 테이블 내에 원하는 데이터를 빠르게 찾을 수 있음**

### 4.5.2 B-Tree

- 루프 노드, 리프 노드, 그리고 루프 노드와 리프 노드 사이에 있는 브랜치 노드로 나뉨
- e.g. E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아닌 E가 있을 법한 리프 노드로 들어가 E를 탐색

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1fde9aa3-6b1b-4019-b747-ed367b7055fc/Untitled.png)

- e.g. 키 57에 해당하는 데이터를 검색해야 한다고 할 때, 57보다 같거나 클 때까지 탐색

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18492cef-5dec-4d3b-ab3d-cb4cda3c1020/Untitled.png)


#### 인덱스가 효율적인 이유

- **효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리구조와 트리 깊이의 대수확장성 때문**
- **대수확장성**
    - 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것
    - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 **최대 인덱스 항목의 수는 4배씩 증가**

### 4.5.3 인덱스 만드는 방법

#### MySQL

- 클러스터형 인덱스
    - 테이블당 하나 설정
    - primary key 옵션으로 기본키로 만들면 클러스터형 인덱스를 생성할 수 있고, 기본키로 만들지 않고 unique not  null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있음
- 세컨더리 인덱스
    - 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스보다 성능이 좋음
    - 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스
    - 다양한 필드를 기반으로 쿼리를 보낼 때 사용

#### MongoDB

- 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨
- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스 설정 가능

### 4.5.4 인덱스 최적화 기법

>**MongoDB를 기반으로 인덱스 최적화 기법 설명**

#### 1. 인덱스는 비용이다

- **인덱스는 두 번 탐색하도록 강요함 ⇒ 인덱스 리스트, 컬렉션 순으로 탐색**
- 컬렉션이 수정되었을 대 인덱스도 수정되어야 함
- 쿼리에 있는 필드에 인덱스를 무작정 설정하는 것은 많은 비용을 요구함
- **컬렉션에서 가져와야 하는 양이 많을수록 인덱스 사용은 비효율적임**

#### 2. 항상 테스팅하라

- 서비스 특징에 따라 달라짐
- **explain() 함수**를 통해 인덱스를 만들고 쿼리를 보낸 이후 테스팅을 하며 걸리는 시간을 최소화해야 함
- MySQL 테스팅 코드

    ```sql
    EXPLAIN
    SELECT * FROM t1
    JOIN t2 ON t1.c1 = t2.c1
    ```


#### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

1. 어떠한 값과 같음을 비교하는 **==이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정**
2. **정렬에는 쓰는 필드라면 그 다음 인덱스로 설정**
3. 다중 값을 출력해야 하는 필드, 즉 **쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정**
4. 유니크한 값의 정도를 카디널리티라고 하며, 이 **카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 함**

## SECTION 4.6 조인의 종류

> **조인 (Join)**
> - 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9e903a4e-130d-41ce-a2bc-be22d46289db/Untitled.png)

### 4.6.1 내부 조인 (Inner Join)

- 왼쪽 테이블과 오른쪽 테이블의 **두 행이 모두 일치하는 행이 있는 부분만 표기**

    ```sql
    SELECT * FROM TalbeA A
    INNER JOIN TableB B ON
    A.key = B.key
    ```


### 4.6.2 왼쪽 조인 (Left Outer Join)

- **왼쪽 테이블의 모든 행이 결과 테이블에 표기**

    ```sql
    SELECT * FROM TableA
    LEFT JOIN TableB B ON
    A.key = B.key
    ```

    - B에 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합 생성

### 4.6.3 오른쪽 조인 (Right Outer Join)

- **오른쪽 테이블의 모든 행이 결과 테이블에 표기**

    ```sql
    SELECT * FROM TableA
    RIGHT JOIN TableB B ON
    A.key = B.key
    ```

    - A에 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합 생성

### 4.6.4 합집합 조인 (Full Outer Join)

- 두 개의 테이블을 기반으로 **조인 조건에 만족하지 않는 행까지 모두 표기**

    ```sql
    SELECT * FROM TableA
    OUTER JOIN TableB B ON
    A.key = B.key
    ```


## SECTION 4.7 조인의 원리

### 4.7.1 중첩 루프 조인 (NLJ, Nested Loop Join)

- **중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법**
- 랜덤 접근에 대한 비용이 많이 증가하므로 **대용량 테이블에서는 사용하지 않음**
- **블록 중첩 루프 조인 (BNL, Block Nested Loop)**
    - 중첩 루프 조인에서 발전하였으며, 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인

### 4.7.2 정렬 병합 조인

- **각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인**

### 4.7.3 해시 조인

- **해시 테이블을 기반으로 하는 조인 방법**
- 두 개의 테이블을 조인한다고 했을 때 **하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적**
- **동등(=) 조인에서만 사용 가능**
- MySQL의 경우 MySQL8.0.18 릴리즈와 함께 해당 기능이 추가됨
- MySQL 해시 조인 단계는 **빌드 단계, 프로브 단계**로 나뉨

  **빌드 단계**

    - 입력 테이블 중 하나를 기반으로 **메모리 내 해시 테이블을 빌드하는 단계**
    - **조인에 사용되는 필드가 해시 테이블 키로 사용됨**
    - 아래 그림은 ‘countries.country_id’가 키로 사용되는 것을 볼 수 있음

      ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc365a32-fdf3-4795-9ae4-201e8d81612f/Untitled.png)

    **프로브 단계**
    
    - 프로브 단계 동안 **레코드 읽기를 시작**
    - 각 테이블은 한 번씩만 읽어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통 성능이 더 좋음
    - 아래 그림은 각 레코드에서 ‘persons.country_id’에 일치하는 레코드를 찾아서 결괏값으로 반환
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83d4532d-95f2-446d-92ca-c9983814370b/Untitled.png)


## 참고

- 면접을 위한 CS 전공지식 노트
- [https://studyandwrite.tistory.com/427](https://studyandwrite.tistory.com/427)
- [https://ko.gadget-info.com/difference-between-strong](https://ko.gadget-info.com/difference-between-strong)
- [https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=choodonggeun&logNo=221514827697](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=choodonggeun&logNo=221514827697)
- [https://hoyashu.tistory.com/6](https://hoyashu.tistory.com/6)
- [https://velog.io/@gillog/DB-11-1N-NM-관계](https://velog.io/@gillog/DB-11-1N-NM-%EA%B4%80%EA%B3%84)
- [https://developer-talk.tistory.com/256](https://developer-talk.tistory.com/256)