# 01. Elasticsearch 살펴보기

## 1.1. Elasticsearch 소개

`Elasticsearch`는 **루씬(Lucene) 기반의 오픈 소스 검색 엔진**입니다.
루씬은 자바 라이브러리이며, 이를 기반으로 JSON 기반의 문서를 저장하고 검색할 수 있으며 분석 작업도 가능합니다.

`Elasticsearch`의 특징은 다음과 같습니다.

1. 준실시간 검색 시스템
   - 실시간이라고 생각될 만큼 색인된 데이터가 빠르게 검색됨
   - `refresh_interval` 기본 값이 1초로 설정되어 있어, 1초마다 refresh 함
2. 고가용성을 위한 클러스터 구성
   - 한 대 이상의 노드로 클러스터를 구성하여 높은 수준의 안정성을 달성하고 부하 분산이 가능함
3. 동적 스키마 생성
   - 입력될 데이터들에 대해 미리 스키마를 정의하지 않아도 동적으로 스키마 생성 가능
4. Rest API 기반의 인터페이스
   - Rest API 기반의 인터페이스를 제공하여 비교적 사용을 위한 진입 장벽이 낮음

## 1.2. 클러스터와 노드 이해하기

**Elasticsearch 클러스터**는 **여러 대의 노드들**이 각자의 역할을 바탕으로 연결되어 **하나의 시스템**처럼 동작하게 되어 있습니다.
그렇기에 클러스터의 성능이 부족하면 노드를 늘려서 대응할 수 있습니다. 하지만, 노드를 늘린다고 반드시 성능이 성능을 높일 수 있는 것은 아닙니다.

클러스터에 대해 자세히 알아보기 전 노드의 종류에 대해 살펴보겠습니다.

|    종류    | 역할                     |
|:--------:|:-----------------------|
|  마스터 노드  | 클러스터 상태 관리 및 메타 데이터 관리 |
|  데이터 노드  | 문서 색인 및 검색 요청 처리       |
| 코디네이팅 노드 | 검색 요청 처리               |
| 인제스트 노드  | 색인되는 문서의 데이터 전처리       |

마스터 노드는 정확히는 **마스터 노드** 와 **마스터 후보 노드**로 구성됩니다.

- 마스터 노드 : 지금 클러스터에서 마스터 노드의 역할을 하고 있는 노드
- 마스터 후보 노드 (Master-eligible) : 마스터 노드에 문제가 생겼을 때 마스터 노드가 될 수 있는 노드

즉, 마스터 노드를 3대로 지정했다면, 마스터 노드 1대와 마스터 후보 노드 2대로 구성된 것입니다.
그리고 1대의 마스터 노드가 죽으면, 2대의 마스터 후보 노드들 중에서 새로운 마스터 노드가 선정됩니다.

노드에 대한 개념을 잡았으니 클러스터에 대해 다시 살펴보겠습니다.
이전에 언급했듯, Elasticsearch 클러스터는 여러 대의 노드들이 하나의 시스템처럼 동작하게 되어 있습니다.
그래서 어떤 노드에 어떤 요청을 해도 **동일한 응답**을 줍니다.

아래와 같이 마스터 노드 3대, 데이터 노드 3대, 코디네이팅 노드 1대로 구성된 클러스터가 있습니다.
여기서 사용자가 마스터 노드에 요청을 하면, 마스터 노드는 문서를 가지고 있는 데이터 노드를 찾아 문서를 가져와 사용자에게 응답을 내려줍니다.

<img width="481" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/715d1743-e662-4dd6-9f5e-b2bb0607ccff">

이렇듯 마스터 노드에게 문서 조회 요청을 하더라도 정상적으로 응답을 받을 수 있습니다.
이러한 요청을 데이터 노드에 해도 동일한 응답을 줍니다.

<img width="481" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/9ec85afc-9566-4ced-adcf-b0761e1274e5">

데이터 노드에 직접 요청을 하면 마스터 노드를 통해 거쳐가는 과정이 줄어들게 됩니다.
이렇듯 불필요한 과정을 줄이기 위해서는 각자 역할에 맞는 노드에 요청을 하는 것도 중요합니다.

코디네이팅 노드는 검색 요청을 처리하기 위한 노드인데, 색인 요청에도 잘 동작합니다.
그렇기에 다음과 같이 코디네이팅 노드에게 색인 요청을 하면, 데이터 노드를 찾아 색인 요청을 전달합니다.

<img width="453" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/a1ed20b1-baea-44c6-8177-f7440a4702d6">

이렇듯 **각각의 노드가 본연의 역할에 충실할 수 있도록 구성을 하는 것이 중요**합니다.

이상적인 클러스터 구성은 다음과 같습니다.

<img width="470" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/9d47e651-6224-4086-a4f3-37467a77cb57">

각 노드에 직접적인 접근은 차단하고, 각 노드 그룹의 앞 단에 **로드 밸런서**를 둡니다.
그리고 검색은 데이터 노드의 로드밸런서로, 색인은 코디네이팅 노드의 로드밸런서로 요청을 합니다.

## 1.3. 인덱스와 샤드 이해하기

### 1.3.1. 인덱스 이해하기

먼저 인덱스가 무엇인지 설명드리기 전, `Elasticsearch`와 `RDBMS`를 비교해보도록 하겠습니다. ~~개념을 익히기 위해 비교하는 것으로, 두 개념이 완전히 동일한 의미를 가지지는 않습니다.~~

| Elasticsearch |  RDBMS   |
|:-------------:|:--------:|
|     index     | database |
|    mapping    |  schema  |
|   document    |   row    |

Elasticsearch의 index는 RDBS의 database와 유사하며, mapping은 schema와, document는 row와 유사합니다.
이 중 index에 대해 먼저 살펴보도록 하겠습니다.

인덱스(index)란 **문서가 저장되는 논리적인 공간**이며, 문서를 저장하기 위해서는 반드시 인덱스가 존재해야 합니다.
그리고 인덱스를 설계하는 것이 Elasticsearch를 사용하기 위해 고려해야 하는 첫 단계입니다.

만약 도서관 자료 검색 시스템을 만든다고 가정하면, 인덱스를 다음과 같이 두 가지로 설계를 할 수 있습니다.

<img width="319" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/a524aaa2-3e1e-497d-80a1-2774a4b220d7">

어떤 방식을 선택하느냐가 설계를 한다는 것이고, 설계에 따라 **문서의 구조** 및 **검색 쿼리**가 달라집니다.

<img width="766" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/dfd42fc6-ecef-41ef-9192-bbe0c2747890">

그리고 인덱스를 설계할 때는 **사용 패턴**과 **문서의 특성**을 고려해야 합니다.

|       케이스       | 장점                               | 단점                               |
|:---------------:|:---------------------------------|:---------------------------------|
| 하나의 인덱스를 사용할 때  | 관리해야 할 인덱스의 수가 적어 관리 리소스가 적게 발생  | 쿼리와 문서의 구조가 복잡해질 수 있음            |
| 여러 개의 인덱스로 나눌 때 | 각각의 경우에 최적화된 쿼리와 문서 구조를 사용할 수 있음 | 관리해야 할 인덱스 수가 많아 관리 리소스 발생할 수 있음 |

시스템이 얼마나 커질지, 복잡해질지 알 수 없다면 **하나의 인덱스로 단순하게 시작**하는 것이 좋습니다.
그리고 추후 시스템이 커진다면 **사용 패턴에 따라 인덱스를 별도로 운영**하는 것이 좋습니다.

### 1.3.2. 샤드 이해하기

샤드(shard)란 **인덱스에 색인되는 문서가 저장되는 공간**입니다.
그렇기에 하나의 인덱스는 반드시 하나 이상의 샤드를 가집니다.

다음과 같이 library 인덱스가 세 개의 샤드를 가진다고 할 때, 색인 요청이 들어오면 0번 샤드에 저장이 됩니다.

<img width="372" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/277b4246-ef37-4d6c-8d14-2acccfa84de9">

이후 색인 요청이 다시 들어오면 그 때는 1번 샤드에, 그 다음 색인 요청은 2번 샤드에 저장이 됩니다.
이렇듯 샤드에 순서대로 데이터를 담아 저장하고 있습니다.

이러한 샤드는 다음과 같은 두 가지 종류로 구분합니다.

1. 프라이머리 샤드
   - 문서가 저장되는 원본 샤드
   - 색인과 검색 성능에 모두 영향을 줌
2. 레플리카 샤드
   - 프라이머리 샤드의 복제 샤드
   - 검색 성능에 영향을 줌
   - 프라이머리 샤드에 문제가 생기면 레플리카 샤드가 프라이머리 샤드로 승격

샤드는 인덱스를 생성할 때, 다음과 같이 명령어를 통해 설정할 수 있습니다.

```bash
PUT /library/_settings
{
  "index": {
    "number_of_shards": 3,
    "number_of_replicas": 1
  }
}
```

위 명령어를 실행하면 프라이머리 샤드가 3개 생성되고, 각 프라이머리 샤드의 레플리카 샤드는 1개씩 생성한다는 의미입니다.
즉, 레플리카 샤드는 `number_of_shards` 값과 `number_of_replicas` 값을 **곱한 결과**인 3개 생성됩니다.
그렇기에 생성된 총 샤드 수는 6개 입니다.

프라이머리 샤드는 생성하고 나면 변경을 할 수 없습니다.
왜냐하면, 샤드의 개수에 따라 문서를 저장하는 `Routing Rule`이 생기기 때문입니다.

```text
Routing Rule = (문서 ID) % (샤드의 개수)
```

문서들은 아래 그림의 좌측과 같이 0번부터 2번까지의 샤드에 순서대로 저장됩니다.
그런데 여기서 새로운 샤드가 추가되면 문서가 저장되는 규칙이 완전히 바뀌게 됩니다.
이러한 문제가 발생하지 않도록 프라이머리 샤드의 개수를 변경할 수 없습니다.

<img width="694" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/7df72c20-3cc1-426b-a8af-8aa7fd2064d9">

그렇기에 인덱스를 생성할 때 프라이머리 샤드의 개수를 설정하는 것은 매우 중요한 작업입니다.
참고로 `number_of_shards`의 기본 값은 1이며, 만약 기본 값을 그대로 사용한다면 성능에 좋지 않은 영향을 끼칩니다.

그렇다면 매번 인덱스를 생성할 때마다 샤드를 설정해야 할까요? 이것은 매우 귀찮은 반복 작업입니다.

Elasticsearch에서는 우리가 이러한 귀찮은 반복 작업을 하지 않도록 **인덱스 템플릿**을 지원합니다.
인덱스 템플릿을 사용하면 **지정한 패턴에 일치하는 인덱스에 원하는 설정 값을 적용**할 수 있습니다.

다음과 같이 인덱스 템플릿을 생성하면 `nginx-logs-`로 시작하는 모든 인덱스는 프라이머리 샤드 3개, 레플리카 샤드 6개를 생성합니다.

```bash
PUT _index_template/base_template
{
  "index_patterns": ["nginx-logs-*"],
  "template": {
    "settings": {
      "number_of_shards": 3,
      "number_of_replicas": 2
    }
  }
}
```

참고로, 인덱스 템플릿을 생성하기 전에 만들었던 인덱스는 영향을 받지 않으며, 인덱스 템플릿 **생성 이후에 만든 인덱스**에만 영향을 끼칩니다.

## 1.4. 매핑 이해하기

매핑(mapping)이란 **문서의 구조를 나타내는 정보**입니다.
간혹 Elasticsearch를 스키마리스라고 생각을 하기도 하는데, 스키마가 없는 것이 아닌 **미리 정의하지 않아도 괜찮은 뿐**입니다.

매핑의 종류는 두 가지로, 동적 매핑과 정적 매핑이 존재합니다.

먼저 **동적 매핑**은 **처음 색인되는 문서를 바탕으로 매핑 정보를 Elasticsearch가 동적으로 생성**합니다.
그렇기에 문서의 매핑 정보를 미리 정의하지 않아도 됩니다.

다음과 같이 매핑을 생성하지 않고 바로 도큐먼트를 생성하면 최초로 입력된 값을 기반으로 매핑 값이 자동으로 생성됩니다.

<img width="330" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/44594598-fe7c-4811-99ae-494e0c57fb46">

그 다음으로 정적 매핑에 대해 알아보겠습니다.
**정적 매핑**은 **문서의 매핑 정보를 미리 정의**하는 것입니다.
다음과 같이 생성할 때 매핑을 정의할 수도 있고, 이전에 설명한 인덱스 템플릿에 매핑 정보를 정의할 수도 있습니다.

```bash
PUT /library
{
  "mappings": {
    "properties": {
      "title": {"type": "text"},
      "rating": {"type": "double"}
    }
  }
}
```

그렇다면 반드시 모든 필드를 정의해야 할까요? 그렇지는 않습니다.

다음과 같이 매핑 정의를 하지 않은 필드를 포함하여 생성한 경우, 정의되지 않은 필드에 대해서는 동적 매핑을 합니다.

<img width="694" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/86ed77d4-bde0-4eb0-9c5f-0352f00034e4">

즉, 반드시 모든 필드를 정의하지 않아도 괜찮습니다.

그렇다면 정적 매핑은 언제 사용하는 것이 좋을까요?

1. 문서의 필드들이 가지는 값에 따라 타입을 지정해 줄 필요가 있을 때
   - e.g. float 최대 값을 넘는 값들이 들어갈 경우가 있다면 double로 정적 매핑 필요 (소수점 기본 값이 float)
2. 불필요한 색인이 발생하지 않기 위해
   - e.g. 문자열 필드마다 자동 생성되는 keyword 타입이 필요하지 않고, text 타입만 필요한 경우

동적 매핑이나 정적 매핑으로 매핑 정보가 생성된 후 **타입이 맞지 않은 값을 색인하려고 하면 파싱 에러가 발생**합니다.

> 본 게시글은 [Elasticsearch Essential](https://www.inflearn.com/course/elasticsearch-essential) 강의를 참고하여 작성되었습니다.
>
> 상세한 내용이 궁금하시다면 강의 수강을 추천해 드립니다.