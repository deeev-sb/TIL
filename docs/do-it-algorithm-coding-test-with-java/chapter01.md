# 01. 어떤 알고리즘으로 풀어야 할까?

## 1.1 시간 복잡도 표기법 알아보기

### 시간 복잡도란?

시간 복잡도는 **주어진 문제를 해결하기 위한 연산 횟수**를 말하며,
일반적으로 수행 시간은 **1억 번의 연산을 1초의 시간으로 간주**하여 예측합니다.

### 시간 복잡도 정의하기
실제 시간 복잡도를 정의하는 유형은 다음과 같이 3가지 입니다.
1. 빅-오메가(`Ω(n)`) : 최선일 때의 연산 횟수를 나타낸 표기법
2. 빅-세타(`⍬(n)`) : 보통일 때의 연산 횟수를 나타낸 표기법
3. 빅-오(`O(n)`) : 최악일 때의 연산 횟수를 나타낸 표기법

### 코딩 테스트에서는 어떤 시간 복잡도 유형을 사용해야 할까?

코딩 테스트에서는 `빅-오 표기법 (O(n))`을 기준으로 수행 시간을 계산하는 것이 좋습니다.
실제 테스트에서는 대부분 모든 테스트 케이스를 통과해야 합격으로 판단하므로
시간 복잡도를 판단할 때는 최악일 때를 염두에 둬야 합니다.

## 1.2. 시간 복잡도 활용하기

### 알고리즘 선택의 기준으로 사용하기
정렬에는 여러 가지가 존재하는 데, 그 중 버블 정렬과 병합 정렬의 시간 복잡도는 각각 O(n^2), O(nlogn)입니다.
(정렬에 대한 내용은 추후에 다룰 예정입니다.)
[BOJ.2750](https://www.acmicpc.net/problem/2750) 문제와 같이 숫자를 오름차순으로 정렬하려고 하며,
시간 제한이 2초이고 백준 문제와 다르게 N의 개수와 절댓값이 1,000,000이라고 가정합시다.
이 경우, 2억 번 이하의 연산 회수로 문제를 해결해야 합니다.

연산 횟수는 다음과 같은 방법으로 계산합니다.

```
연산 횟수 = 알고리즘 시간 복잡도 X 데이터 크기
```

위 공식을 대입해 각 알고리즘이 문제에 적합한지 판단해 보겠습니다.

```
버블 정렬 = 1,000,000 * 1,000,000 = 1,000,000,000,000 > 200,000,000 → 부적합
병합 정렬 = 1,000,000log(1,000,000) = 약 20,000,000 < 200,000,000 → 적합
```

연산 횟수를 계산한 결과에 따라, 버블 정렬은 적합한 알고리즘이 아니며 병합 정렬이 적합한 알고리즘이라 판단할 수 있습니다.
이와 같이 시간 복잡도 분석으로 문제에서 사용할 수 있는 알고리즘을 선택할 수 있고, 이 범위를 바탕으로 문제의 실마리를 찾을 수 있습니다.
즉, 데이터의 크기(N)를 단서로 사용해 알고리즘을 추측할 수 있습니다.

### 시간 복잡도를 바탕으로 코드 로직 개선하기
시간 복잡도는 작성한 코드의 비효율적인 로직을 개선하는 바탕으로도 사용할 수 있습니다.
이를 위해 시간 복잡도를 도출해야 하며, 그 과정에서 다음 기준을 고려해야 합니다.

1. 상수는 시간 복잡도 계산에서 제외한다.
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

해당 챕터에서 나온 BOJ.2750를 직접 푼 풀이는 아래 링크 걸어두었습니다. 😄😄

👉 [문제 풀이 보러가기](https://github.com/Kim-SuBin/Algorithm/blob/main/doit/chapter01/Ch01P01.java)


> 본 게시글은 [Do it! 알고리즘 코딩 테스트 - 자바편](https://product.kyobobook.co.kr/detail/S000001818060) 도서를 참고하여 작성되었습니다.
> 
> 개념에 대한 상세한 내용과 알고리즘 문제에 대한 상세한 풀이가 궁금하시다면 책을 읽어보시길 추천드립니다.