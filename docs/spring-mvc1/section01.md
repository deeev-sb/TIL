# 01. 웹 애플리케이션 이해

## 1.1. 웹 서버, 웹 애플리케이션 서버

### 1.1.1 웹 서버 vs. 웹 애플리케이션 서버

웹 서버 (Web Server)와 웹 애플리케이션 서버 (WAS - Web Application Server)는 모두 **`HTTP`를 기반으로 동작**합니다.
웹 서버와 웹 애플리케이션의 차이는 다음과 같습니다.

|             | 특징                                                                                                                                          |              예              |
|:-----------:|:--------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------:|
|    웹 서버     | - 정적 리소스 및 기타 부가 기능 제공<br/>- 정적 리소스 : 정적(파일) HTML, CSS, JS, 이미지, 영상                                                                         |        NGINX, APACHE        |
| 웹 애플리케이션 서버 | - 웹 서버 기능을 포함하고 있음 (정적 리소스 제공 가능)<br/>- 프로그램 코드를 실행해서 애플리케이션 로직 수행<br/>&nbsp;&nbsp;- 동적 HTML, HTTP API(JSON)&nbsp;&nbsp;- 서블릿, JSP, 스프링 MVC | 톰캣(Tomcat), Jetty, Undertow |

사실 웹 서버와 웹 애플리케이션 서버의 용어에 대한 경계가 모호합니다.
웹 서버도 프로그램을 실행하는 기능을 포함하기도 하고, 웹 애플리케이션 서버도 웹 서버의 기능을 제공합니다.
기억하기 쉽게 정리하면, **웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직**을 제공합니다.

### 1.1.2 웹 시스템 구성

웹 시스템은 `WAS`와 `DB`만으로 시스템을 구성할 수 있습니다. 왜냐하면, `WAS`가 정적 리소스와 애플리케이션 로직을 모두 제공하기 때문입니다.

<img width="330" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/564e07db-22d1-4c0b-88f2-b9ff8f13dfcc">

그런데 이렇게 WAS가 너무 많은 역할을 담당하면, 서버 과부하가 발생할 수 있습니다.
정적 리소스는 단순히 파일을 내려주는 것이기에 비용이 싼데, 이러한 **정적 리소스 때문에 가장 비싼 애플리케이션 로직 수행이 어려울 수 있기** 때문입니다.
뿐만 아니라, **WAS에서 장애가 발생하면, 오류 화면도 노출할 수 없습니다.**

이러한 문제를 해결하기 위해서는 다음과 같이 **정적 리소스를 웹 서버가 처리**하도록 구성해야 합니다.
웹 서버는 애플리케이션 로직 같은 동적 처리가 필요한 부분에 대해서만 WAS에 요청을 위임하며, WAS는 중요한 애플리케이션 로직에 대한 처리를 전담하게 됩니다.

<img width="637" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/078bbbd8-e4f3-4dd8-9487-fa4a32fd9a8e">

그리고 이렇게 구성하면, **리소스 관리를 효율적**으로 할 수 있습니다.
정적 리소스가 많이 사용되면 웹 서버를 증설하면 되고, 애플리케이션 리소스가 많이 사용되면 WAS를 증설하면 되기 때문입니다.

또한, 정적 리소스만 제공하는 웹 서버는 WAS와 달리 잘 죽지 않습니다.
그렇기에 WAS나 DB에서 장애가 발생하여도, **WEB 서버가 오류 화면을 제공**할 수 있습니다.

<img width="635" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/f5d0b7fa-3647-4203-95c9-b322cd400465">

## 1.2. 서블릿

다음 그림의 클라이언트는 이름과 나이를 입력한 다음 전송 버튼을 누르면 회원 가입이 되는 `HTML Form`이라고 가정하겠습니다.

<img width="537" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/919c57a6-64b3-4356-bf8c-b9db14055a78">

`HTML Form`을 자세히 살펴보면 `URL`은 `/save`이고, `method`를 보아 `POST` 방식으로 데이터를 전송한다는 사실을 알 수 있습니다.
이 때, `body`는 `username`이라는 필드와 `age`라는 필드를 가지며, 각 필드의 값은 사용자가 입력한 이름과 나이입니다.
클라이언트에서 **전송**을 클릭하면 우측과 같은 요청 HTTP 메시지를 생성하며, `HTML Form` 형태로 전송하면 `Content-Type`은 일반적으로 `application/x-www-form-urlencoded`로 설정됩니다.

만약 웹 애플리케이션 서버를 밑바닥부터 직접 구현한다면, 다음 그림의 좌측 목록과 같은 일련의 과정을 진행해야 합니다.
그러나 이 중 의미있는 비즈니스 로직은 **비즈니스 로직 실행** 뿐입니다.

<img width="605" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/75aec815-bef8-401b-92c5-041bb2ca5fd2">

그런데 서블릿을 지원하는 WAS를 사용하게 되면, 의미있는 비즈니스 로직만 수행하면 됩니다. 그 외에 줄로 그은 부분은 모두 서블릿이 자동화해주기 때문입니다.

<img width="501" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/b4f26ae7-11b9-48ff-a44c-12b3d38c16b4">

서블릿은 다음과 같이 `@WebServlet` 어노테이션을 사용하고, `HttpServlet`을 상속 받으면 됩니다.

```java
@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
    
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) {
        // 애플리케이션 로직
    }
}
```

`urlPatterns`의 URL(/hello)이 호출되면 서블릿 코드가 실행됩니다.
그리고 `HttpServletRequest`를 통해 `HTTP` 요청 정보를 사용할 수 있고,
`HttpServletResponse`를 통해 `HTTP` 응답 정보를 편리하게 제공할 수 있습니다.
그렇기에 개발자는 `HTTP` 스펙을 매우 편리하게 사용할 수 있게 됩니다.
참고로, 개발자는 기본적인 `HTTP` 스펙에 대해서는 알고 있어야 합니다.

서블릿을 통해 통신을 주고 받는 전체 흐름은 다음과 같습니다.

<img width="734" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/dbd9cddc-b055-4db0-adef-96319b49e344">

1. 웹 브라우저에서 WAS로 `localhost:8080/hello` 요청
2. WAS는 request, response 객체를 새로 만들어 서블릿 객체 (`helloServlet`) 호출
3. request, response 객체를 파라미터로 서블릿 컨테이너의 `helloServlet` 실행
4. 서블릿 컨테이너의 `helloServlet`이 종료되면 반환되는 response 객체 정보를 바탕으로 HTTP 응답 생성
5. WAS에서 웹 브라우저로 응답 메시지 전송

그렇다면 서블릿 컨테이너는 무엇일까요? 사실 우리는 서블릿을 사용하기 위해 코드를 작성하기만 했습니다.
실제로 **서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리**하는 것은 **서블릿 컨테이너**입니다/

<img width="493" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/153a9a34-91fd-477c-8fd9-f548178a3db1">

톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 하며, 다음과 같은 **특징**을 가집니다.

- 서블릿 객체는 **싱글톤으로 관리**
  - 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재사용
  - 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
  - 서블릿 컨테이너 종료 시 함께 종료
  - **공유 변수 사용 시 주의**
- JSP도 서블릿으로 변환되어서 사용됨
- 동시 요청을 위한 **멀티 쓰레드 처리 지원**

## 1.3. 동시 요청 - 멀티 쓰레드

클라이언트에서 요청을 하면 TCP/IP 연결이 되고, 서블릿 객체를 호출합니다.

<img width="307" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/c09025a2-82fc-4684-9772-1a4a6c315558">

여기서 서블릿 객체를 호출하는 것은 **쓰레드**입니다.

쓰레드란 **애플리케이션 코드를 하나하나 순차적으로 실행하는 것**으로, 자바 메인 메서드를 처음 실행하면 `main`이라는 이름의 쓰레드가 실행됩니다.
만약 쓰레드가 없다면 자바 애플리케이션 실행 자체가 불가능합니다.
그리고 쓰레드는 **한 번에 하나의 코드 라인만 수행**하며, **동시 처리**가 필요하면 쓰레드를 **추가로 생성**합니다.

만약 WAS 내에 **쓰레드가 하나**만 존재한다면 어떻게 되는지 알아보도록 하겠습니다.

<img width="307" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/b3f654fe-3b7a-4fae-833f-a5048470a6b5">

클라이언트로부터 요청이 들어오면 휴식 중인 쓰레드를 **할당**하고, 쓰레드가 **서블릿 객체를 호출**합니다.

<img width="306" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/671d0a82-abfa-41b9-8c3d-308e4a9a56eb">

그러면 서블릿 객체에서 response 객체 정보를 만들고, **응답이 클라이언트로 전송**됩니다.

<img width="306" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/97270f85-2747-4bdd-925d-32e7efffb28c">

요청에 대한 응답을 내려주고 나면 쓰레드는 더 이상 할 일이 없기 때문에 다시 **휴식** 상태가 됩니다.

<img width="306" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/9b6cae98-951c-46fb-abc2-ac0afdc088ab">

그렇다면 하나의 쓰레드에 **다중 요청**이 들어오면 어떻게 될까요?
다음과 같이 먼저 들어온 요청 1에 대한 처리가 지연되고 있을 때, 요청 2가 들어오면 현재 쓰레드가 작업 중이기 때문에 **대기** 상태가 됩니다.

<img width="306" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/cc1be61a-f0c6-431f-bf13-d3c8f1bedb7d">

그런데 이 상황이 **지속**되면 결국 두 요청 모두 `Timeout` 등의 **오류가 발생**하게 됩니다.

이러한 문제를 해결할 수 있는 가장 단순한 방법은 **요청마다 쓰레드를 생성**하는 것입니다.

<img width="306" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/1bcb021a-70ec-442b-a12e-93841e113116">

이렇게 요청마다 쓰레드를 생성하면 **동시 요청을 처리**할 수 있고, 하나의 쓰레드가 지연 되어도 나머지 쓰레드는 정상 동작합니다.
그리고 **리소스(CPU, 메모리)가 허용할 때까지 처리**할 수 있습니다. 그러나 장점만 있는 것은 아닙니다.

쓰레드는 **생성 비용이 매우 비쌉니다.** 그렇기에 고객의 요청이 올 때마다 쓰레드를 생성하면 응답 속도가 느려집니다.
또한, 쓰레드는 **컨텍스트 스위치 비용이 발생**합니다. 그리고 **쓰레드 생성에 제한이 없어** 너무 많은 요청이 들어오면 CPU나 메모리의 임계점을 넘어 **서버가 다운**될 수 있습니다.

이러한 문제를 예방하기 위해 `WAS`는 다음과 같이 쓰레드를 보관하고 관리하는 **쓰레드 풀**을 가집니다.
쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리하며, 톰캣은 최대 200개가 기본 설정으로 되어 있습니다.

<img width="401" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/e9ae70b9-300d-4380-8b4d-e2bb222a4d4b">

쓰레드가 필요할 때마다, 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내서 사용합니다.
그리고 사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납합니다.

만약 최대 쓰레드가 모두 사용 중이어서 쓰레드 풀에 쓰레드가 없다면, 기다리는 요청을 거절하거나 특정 숫자만큼만 대기하도록 설정할 수 있습니다.

<img width="401" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/fedd0bda-7e63-4642-a9a4-639ae1db0324">

쓰레드 풀을 사용하면 다음과 같은 장점이 있습니다.

- 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고 응답 시간이 빠름
- 생성 가능한 쓰레드의 최대치가 있으므로, 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있음

여기서 핵심은 **WAS는 멀티 쓰레드를 지원**한다는 것입니다.
멀티 쓰레드에 대한 부분을 WAS가 처리하기 때문에 **개발자는 멀티 쓰레드 관련 코드를 신경쓰지 않아도 됩니다.**
개발자는 마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발할 수 있습니다.
단, 멀티 쓰레드 환경이므로 **싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용**해야 합니다.

::: tip ✅ 쓰레드 풀 실무 팁

WAS의 주요 튜닝 포인트는 **최대 쓰레드(max thread) 수** 입니다.
이 값을 **너무 낮게 설정**하면, 많은 동시 요청이 들어올 때 서버 리소스는 여유롭지만 클라이언트는 빠르게 **응답 지연**을 만나게 됩니다.
이 값을 **너무 높게 설정**하면, 많은 동시 요청이 들어올 때 CPU, 메모리 리소스 임계점을 초과하여 **서버가 다운**됩니다.

많은 요청으로 인해 장애가 발생하게 된다면 어떻게 해야 할까요?

클라우드인 경우 우선 서버를 늘리고 난 다음 이후에 튜닝을 하면 되고, 아니라면 평상시에 열심히 튜닝을 해야 합니다.

그렇다면 **쓰레드 풀의 적정 숫자**는 어떻게 될까요?
애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 적정 숫자는 달라집니다.
그렇기 때문에 최대한 실제 서비스와 유사하게 **성능 테스트**를 하며 적정 숫자를 찾는 것이 중요합니다.
이러한 성능 테스트를 하기 위한 툴로는 ApacheBench(ab), jMeter, nGrinder 등이 있습니다.

:::

## 1.4. HTML, HTTP API, CSR, SSR

### 1.4.1. HTML

HTML, HTTP API, CSR, SSR에 대해 살펴보기 전, 먼저 **정적 리소스**에 대해 간단히 알아보겠습니다.
정적 리소스는 **고정**된 HTML 파일이나 CSS, JS, 이미지, 영상 등을 의미하며, 주로 웹 브라우저에서 요청을 합니다.

<img width="280" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/c2a05608-f946-4006-9745-9fbddf393588">

다음과 같이 **HTML** 파일을 **동적**으로 생성하여 전달할 수도 있습니다.
주문 정보 조회와 같이 사용자에 따라 다른 정보를 내려주어야 하는 경우나 실시간 인기 검색어와 같이 시간에 따라 변화되는 정보를 내려주는 경우 등이 있습니다.
WAS에서 HTML 페이지를 동적으로 생성할 때는 `JSP`나 `Thymeleaf`를 사용합니다.

<img width="392" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/f531b0fd-c141-405f-811c-88202f5f9b62">

### 1.4.2. HTTP API

HTML이 아니라 **데이터**를 전달할 때는 **HTTP API**를 사용합니다.
주로 **JSON** 형식으로 사용하며, 다양한 시스템에서 호출할 수 있습니다.

<img width="444" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/a21f5cfa-5b7f-4b11-9497-ffdc436a331c">

웹 브라우저에서는 자바스크립트를 통해 HTTP API를 호출하며, 웹 클라이언트로는 React, Vue.js 등이 있습니다.
그리고 앱 클라이언트는 아이폰, 안드로이드, PC 앱 등이 있습니다.
이러한 **UI 클라이언트와 서버** 간 HTTP API 통신 뿐만 아니라, **서버와 서버** 간 HTTP API 통신도 존재합니다.
위 이미지와 같이 주문 서버와 결제 서버 간 통신이나 기업 간 데이터 통신 등이 여기에 속합니다.

### 1.4.3. SSR

**SSR**은 서버 사이드 렌더링으로, **서버에서 최종 HTML을 생성해서 클라이언트에 전달**하는 것입니다.
다시 말해, 백엔드 개발자가 서버에서 동적으로 HTML을 생성하고 웹 브라우저에서는 생성된 정적인 HTML 페이지를 전달받습니다.
이와 관련된 기술로는 `JSP`, `Thymeleaf`가 있습니다.

<img width="392" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/f531b0fd-c141-405f-811c-88202f5f9b62">

### 1.4.4. CSR

**CSR**은 클라이언트 사이드 렌더링으로, **HTML 결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성하여 적용**하는 것입니다.
주로 동적인 화면에서 사용하며, 웹 화면을 마치 앱처럼 **필요한 부분만 변경** 할 수 있습니다. 이러한 예로는 구글 지도나 Gmail, 구글 캘린더 등이 있습니다.
이와 관련된 기술로는 `React`, `Vue.js`가 있으며, 웹 프론트엔드 개발자가 개발을 합니다.
그리고 아래와 같은 과정으로 웹 브라우저에 데이터를 표출합니다.

<img width="421" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/2a2bb7ea-b54b-4a7c-b00f-e7ad516b0058">

참고로, CSR과 SSR을 동시에 지원하는 웹 프레임워크도 있으며, SSR을 사용하더라도 자바스크립트를 사용해 일부 화면을 동적으로 변경할 수 있습니다.

## 1.5. 자바 백엔드 웹 기술 역사

**자바 웹 기술**이 발전한 순서는 다음과 같습니다.

- 1997 서블릿
  - HTML 생성이 어려움
- 1999 JSP
  - HTML 생성은 편리하지만, 비즈니스 로직까지 너무 많은 역할을 담당함
- 서블릿, JSP 조합 ⇒ MVC 패턴 사용
  - 모델, 뷰, 컨트롤러로 역할을 나누어 개발
- 2000년 초 ~ 2010년 초 MVC 프레임워크 춘추 전국 시대
  - MVC 패턴 자동화, 복잡한 웹 기술을 편리하게 사용할 수 있는 다양한 기능 지원
  - 스트럿츠, 웹워크, 스프링 MVC(과거 버전)
- 애노테이션 기반의 스프링 MVC (현재 사용하는 기술)
  - `@Controller`
  - MVC 프레임워크의 춘추 전국 시대 마무리
  - 유연하고 편리하게 MVC 코드를 작성할 수 있음
- 스프링 부트 (현재 사용하는 기술)
  - 스프링 부트는 서버를 내장하고 있음
  - 과거에는 서버에 WAS를 직접 설치하고, 소스는 War 파일을 만들어서 설치한 WAS를 배포했음
  - 스프링 부트는 빌드 결과(Jar)에 WAS 서버를 포함하고 있음 ⇒ **빌드 배포 단순화**

최근에는 스프링 웹 기술은 다음과 같이 두 가지로 세분화되었습니다.
- `Web Servlet` 기반의 `Spring MVC`
- `Web Reactive` 기반의 `Spring WebFlux`

스프링 웹 플럭스는 최신 기술이기에 특징을 간단히 정리하도록 하겠습니다.

- 비동기 Non-Blocking 처리
- 최소 쓰레드로 최대 성능을 낼 수 있음 : 쓰레드 컨텍스트 스위칭 비용 효율화
- 함수형 스타일로 개발 : 동시 처리 코드 효율화
- 서블릿 기술 사용 X

그러나 웹 플럭스는 기술적 난이도가 매우 높으며, 일반 MVC의 쓰레드 모델도 충분히 빠릅니다.

HTML을 편리하게 생성하는 **자바 뷰 템플릿**이 발전한 순서는 다음과 같습니다.

- JSP
  - 속도 느림
  - 기능 부족
  - 권장하지 않음
- 프리마커(Freemarker), 벨로시키(Velocity)
  - 속도 문제 해결
  - 다양한 기능 제공
- 타임리프(Thymeleaf)
  - 내추럴 템플릿 : HTML의 모양을 유지하면서 뷰 템플릿 적용 가능
  - 스프링 MVC와 강력한 기능 통합
  - 만약 자바 뷰 템플릿을 공부한다면, **최선의 선택**
  - 단, 성능은 프리마커, 벨로시티가 더 빠름

> 본 게시글은 [스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1) 강의를 참고하여 작성되었습니다.
>
> 상세한 내용이 궁금하시다면 강의 수강을 추천해 드립니다.