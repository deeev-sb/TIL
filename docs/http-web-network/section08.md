# 08. HTTP 헤더 2 - 캐시와 조건부 요청

## 8.1. 캐시 기본 동작

먼저, 캐시가 없는 상황에 대해 알아보겠습니다.

다음와 같이 웹 브라우저에서 `star.jpg`를 요청하면, 서버는 `star.jpg`를 내려줍니다.
이 때 HTTP 헤더를 0.1M, HTTP 바디를 1.0M라고 가정하면, 1.1M의 네트워크를 차지하며 웹 브라우저에 응답 데이터가 내려옵니다.
그러면 웹 브라우저 내에 이미지가 표출되게 됩니다.

<img width="512" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/d8c6f4dc-0088-4c01-9b58-f46831e72c9c">

그리고 `star.jpg`를 다시 요청하면, 서버로부터 1.1M의 네트워크를 차지하며 이미지가 응답 데이터로 내려옵니다.

<img width="370" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/cbc9ac79-a102-4211-823b-7f54ee736687">

이렇듯 캐시가 없으면, **데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 다운로드 받아야 합니다.**
그런데 이러한 인터넷 네트워크는 **매우 느리고 비쌉니다.**
뿐만 아니라, 매번 데이터를 받아오는 것은 브라우저의 **로딩 속도를 느리게** 만들고,
사용자는 **느린 경험**을 하게 됩니다. 

요약하여 정리하면 **캐시가 없을 때의 특징**은 다음과 같습니다.

- 데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 다운로드 받아야 함
- 인터넷 네트워크는 매우 느리고 비쌈
- 브라우저 로딩 속도가 느림
- 느린 사용자 경험

이번에는 캐시를 적용하면 어떻게 되는지 알아보겠습니다.

이전과 동일하게 웹 브라우저는 `star.jpg`를 요청하며, 서버는 `star.jpg`를 내려줍니다.
이 때, 헤더 내에 `cache-control`이라고 하는 **캐시 정보**를 포함합니다.
그러면 웹 브라우저는 `star.jpg`를 캐시에 저장합니다.

<img width="345" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/e9140144-7326-4500-b32b-30db10efd9a2">

두 번째 요청이 `cache-control`에서 지정한 60초라는 시간 내에 들어오면,
다음과 같이 서버가 아닌 캐시에서 `star.jpg`를 가져옵니다.

<img width="368" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/0ca4aa8b-4f27-41e7-9f6c-ab09d253bd58">

이렇듯, 캐시를 적용하면 **네트워크를 사용하지 않아도 되어서** 비싼 네트워크 사용량을 줄일 수 있습니다.
그리고 이미 불러온 데이터에 대해서는 **브라우저 로딩 속도가 매우 빠르며,**
그로 인해 사용자는 **빠른 사용자 경험**을 하게 됩니다.

요약하여 정리하면 **캐시의 특징**은 다음과 같습니다.

- 캐시 가능 시간 동안 네트워크를 사용하지 않아도 됨
- 비싼 네트워크 사용량을 줄일 수 있음
- 브라우저 로딩 속도가 매우 빠름
- 빠른 사용자 경험

그렇다면 캐시가 유효한 시간이 초과된 이후 요청하면 어떻게 될까요?

다음과 같이 웹 브라우저는 브라우저 캐시가 초과되었는지 확인한 다음, 서버에 요청을 합니다.
그리고 서버는 `star.jpg` 정보와 캐시 유효 시간을 다시 알려줍니다.
그러면 웹 브라우저는 기존 캐시 정보를 지우고, 새로 받은 응답 데이터를 캐시에 저장합니다.

<img width="407" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/94b37b43-07af-478f-91e6-8b91e5fb62c3">

즉, **캐시 유효 시간이 초과하면 서버를 통해 다시 조회하고 캐시를 갱신**합니다.
이 때 다시 네트워크 다운로드가 발생합니다.

그런데 캐시 만료 이후 받아온 데이터가 이미 캐시 내에 저장된 데이터와 동일하다면, 다시 다운로드를 받을 필요가 있을까요?
이러한 의문을 해결할 수 있는 내용은 아래에 이어서 살펴보도록 하겠습니다.

## 8.2. 검증 헤더와 조건부 요청

캐시 유효 시간이 초과해서 서버에 다시 요청을 하게 되면 다음과 같은 두 가지 상황이 나타납니다.

1. 서버에서 기존 데이터를 변경함
2. 서버에서 기존 데이터를 변경하지 않음

이 때 2번과 같이 캐시 만료 후에도 서버에서 데이터를 변경하지 않은 경우, 요청 후 다시 다운로드 받는 것이 아닌 브라우저 캐시를 재사용 할 수 있습니다.
단 클라이언트의 데이터와 서버의 데이터가 같다는 사실이 확인되어야만 가능하며, 이를 가능하게 해주는 것이 **검증 헤더**와 **조건부 요청 헤더**입니다.

다음과 같이 서버에서 웹 브라우저의 요청에 대한 응답을 내려줄 때, `Last-Modified`를 포함해서 전달합니다.
그러면 브라우저 캐시는 캐시 유효 기간과 데이터 최종 수정일을 함께 저장합니다.

<img width="466" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/e3012c82-a42c-4292-bed6-b4783987c60f">

60초가 지난 다음 웹 브라우저에서 동일한 요청을 보낼 때, 요청에 `if-modified-since`라는 필드에 데이터 최종 수정일을 포함하여 서버로 보냅니다.
서버는 웹 브라우저가 보낸 날짜와 가지고 있던 데이터 정보를 확인합니다.

<img width="423" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/2419afb1-eea3-483d-853c-6f973a5be1e3">

변경된 것이 없으면 다음과 같이 `304 Not Modified`를 보냅니다.
이 때 이미지 정보를 보내줄 필요가 없기에 HTTP Body를 포함하지 않습니다. 즉, 네트워크를 0.1M 만큼만 사용합니다.
그리고 웹 브라우저는 서버로부터 데이터가 변경되지 않음을 전달받았기에, 기존에 저장된 캐시의 정보를 갱신합니다.

<img width="520" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/eb84857f-f94e-48a4-b90e-4f848d88a4f1">

결과적으로 웹 브라우저는 새로 데이터를 다운로드 받지 않고 캐시에 저장된 데이터를 사용해 `star.jpg`를 띄웁니다.

<img width="287" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/7e77ddfb-5577-4a93-97d9-66e3fed933c7">

정리하면 다음과 같습니다.

- 캐시 유효 시간이 초과해도 서버의 데이터가 갱신되지 않으면, `304 Not Modified`와 함께 헤더 메타 정보만 응답 (바디 X)
- 클라이언트는 서버가 보낸 응답 헤더 정보를 사용하여 캐시의 메타 정보 갱신
- 클라이언트는 캐시에 저장되어 있는 데이터 재활용
- 결과적으로, 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 ⇒ **매우 실용적인 해결책**

그렇다면 검증 헤더와 조건부 요청 헤더는 어떤 것인지 지금부터 살펴보겠습니다.

검증 헤더와 조건부 요청 헤더에 대해서도 간략하게 살펴보겠습니다.

- 검증 헤더
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - `LastModified`, `ETag`
- 조건부 요청 헤더
  - 검증 헤더로 조건에 따른 분기를 서버에 요청
  - `If-Modified-Since`, `If-Unmodified-Since` : 이전에 서버로부터 전달 받은 `Last-Modified` 사용
  - `If-None-Match`, `If-Match` : 이전에 서버로부터 전달 받은 `ETag` 사용
  - 조건 만족 → `200 OK`
  - 조건 만족 X → `304 Not Modified`

`Last-Modified`와 `If-Modified-Since`는 이전에 살펴본 예제에서 사용하였습니다. 그리고 `If-Unmodified-Since`는 조건이 반대입니다.
그런데 `Last-Modified`를 사용하면 다음과 같은 단점이 발생합니다.

- 1초 미만 (0.X초) 단위로 캐시 조정 불가
- 날짜 기반의 로직 사용
- 데이터 수정 날짜는 다르지만, 데이터 자체는 같을 때도 다운로드 받아야 함 (날짜 기반이므로!)
- 서버에서 별도의 캐시 로직을 관리하고 싶어도 날짜 기반이라 불가능
  - e.g. 스페이스나 주석처럼 크게 영향이 없는 변경이어서 굳이 다운로드 받게 하고 싶지 않은 경우

이러한 문제를 해결할 수 있는 방법이 `ETag`입니다.
`ETag`(Entity Tag)는 **캐시 제어 로직을 서버에서 완전히 관리**할 수 있으며, 클라이언트는 캐시 메커니즘을 몰라도 됩니다.
이러한 `ETag`는 `v1.0`과 같이 임의의 고유한 버전을 달아둘 수도 있고, 해시를 활용해 데이터가 변경될 때마다 새로운 해시를 생성하여 `ETag`를 변경하는 등 다앙한 방법으로 설정할 수 있습니다.

## 8.3. 캐시와 조건부 요청 헤더

캐시 제어와 관련된 헤더는 다음과 같이 세 가지 입니다.

- `Cache-Control` : 캐시 지시어(directives)
  - `Cache-Control:max-age` : 캐시 유효 기간, 초 단위
  - `Cache-Control:no-cache` : 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
  - `Cache-Control:no-store` : 데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)
- `Pragma` : 캐시 제어 (하위 호환)
  - `Pragma:no-cache`
  - HTTP 1.0 하위 호환으로 지금은 거의 사용하지 않음
- `Expires` : 캐시 유효 기간 (하위 호환)
  - `expires: Mon, 01 Jan 1990 00:00:00 GMT`
  - 캐시 만료일을 정확한 날짜로 지정
  - HTTP 1.0부터 사용
  - 지금은 더 유연한 `Cache-Control:max-age`를 권장하며, 이와 함께 `Expires`가 사용되면 `Expires`는 무시

`Pragma`나 `Expires`는 `Cache-Control`의 하위 호환이며, 지금은 `Cache-Control`을 통해 다 할 수 있습니다.

## 8.4. 프록시 캐시

원(origin) 서버는 요청에 대한 응답을 내려주는 진짜 서버입니다.
그런데 원 서버가 다음과 같이 미국에 있고, 클라이언트는 한국에 있다면,
한국에 있는 클라이언트는 매우 느린 속도로 응답을 받게 됩니다. ~~여기서는 최대한 긍적적으로 500ms로 잡았다고 합니다~~

<img width="433" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/4ae7efa9-fdd0-4c8d-8d8f-52517f58d129">

매번 요청할 때마다 느린 속도로 응답을 받지 않게 하기 위해서는 다음과 같이 프록시 캐시 서버를 한국 내에 도입합니다.
CDN 서비스나 AWS CloudFront가 이러한 프록시 캐시 서버입니다.
그렇게 되면 웹 브라우저는 한국 내에 있는 프록시 캐시 서버로 요청을 보내도록 되어 있는 것을 확인하고, 프록시 캐시 서버에 요청을 하게 됩니다.
참고로, 웹 브라우저 내에 있는 캐시는 `private` 캐시이고, 프록시 캐시 서버가 가지는 캐시는 `public` 캐시입니다.

<img width="454" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/43b0dc9a-9115-4159-832d-b84797df5f71">

프록시 캐시 서버가 캐시 데이터를 가지게 되는 방법은 두 가지 정도 있습니다.

1. 웹 브라우저의 최초 요청 시 응답 데이터를 프록시 캐시 서버가 캐시에 저장 (대부분 사용하는 방법)
2. 원 서버에서 프록시 캐시 서버로 데이터를 밀어 넣음

이 때, public 캐시는 공용으로 쓸 수 있는 데이터만 저장되어야 하며, 사용자와 관련된 데이터가 포함되어서는 안됩니다.

이와 관련된 `Cache-Control`에 대해 살펴보겠습니다.

- `Cache-Control: public` : 응답이 public 캐시에 저장되어도 됨
- `Cache-Control: private` : 응답이 해당 사용자만을 위한 것임. private 캐시에 저장해야 함 (기본 값)
- `Cache-Control: s-maxage` : 프록시 캐시에만 적용되는 max-age
- `Age: 60` (HTTP 헤더) : 오리진(원) 서버에서 응답 후 프록시 캐시 내에 머문 시간 (초)

## 8.5. 캐시 무효화

`Cache-Control`에는 확실한 캐시 무효화 응답이 존재합니다.

- `Cache-Control: no-cache`
  - 데이터는 캐시해도 되지만, 항상 **원 서버에 검증**하고 사용
- `Cache-Control: no-store`
  - 데이터에 민감한 정보가 있으므로 저장하면 안됨 (메모리에서 사용하고 최대한 빨리 삭제)
- `Cache-Control: must-revalidate`
  - 캐시 만료 후 최초 조회 시 **원 서버에 검증**해야 함
  - 원 서버 접근 실패 시 반드시 오류가 발생해야 함 - 504(Gateway Timeout)
  - must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
- `Pragma: no-cache`
  - HTTP 1.0 하위 호환

그런데 `no-cache`와 `must-revalidate`는 유사해보입니다. 이 두 가지는 어떤 차이가 있는지 지금부터 알아보겠습니다.

먼저, `no-cache`는 기본적으로 다음과 같이 요청을 주고 받습니다.

<img width="538" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/1bda2383-9932-40ee-928a-4c0c888c6163">

그런데 만약 순간적으로 네트워크가 단절되어 원 서버에 접근할 수 없다면,
`no-cache`는 프록시 캐시 서버 벌정에 따라 `Error`를 반환하거나 오래된 데이터를 포함하여 `200 OK`를 내려줍니다.

<img width="498" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/e2e31836-0912-425f-a165-758c9c6c3db6">

`must-revalidate`는 동일한 상황에 무조건 `504 Gateway Timeout`를 반환합니다.

<img width="495" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/7a76eff1-b14a-4690-ae26-4a5aebf583bf">


> 본 게시글은 [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard) 강의를 참고하여 작성되었습니다.
>
> 상세한 내용이 궁금하시다면 강의 수강을 추천해 드립니다.