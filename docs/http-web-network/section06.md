# 06. HTTP 상태 코드

## 6.1. HTTP 상태 코드 소개

HTTP 상태 코드는 **클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능**입니다.

HTTP 상태 코드 종류는 다음과 같습니다.

- 1xx (Informational) : 요청이 수신되어 처리 중
- 2xx (Successful) : 요청 정상 처리
- 3xx (Redirection) : 요청을 완료하려면 추가 행동이 필요
- 4xx (Client Error) : 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
- 5xx (Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함

그러면 만약 모르는 상태 코드가 나타나는 경우 어떻게 해야 할까요?

클라이언트는 **상위 상태 코드로 해석해서 처리**하면 됩니다.
그렇기에 미래에 새로운 상태 코드가 추가되어도 클라이언트를 변경하지 않아도 됩니다.
- 299 ??? → 2xx (Successful)
- 451 ??? → 4xx (Client Error)
- 599 ??? → 5xx (Server Error)

1xx 대는 거의 사용하지 않으므로 생략하고 2xx부터 5xx에 대해 살펴보도록 하겠습니다.

## 6.2. 2xx - 성공

대표적인 2xx 요청은 다음과 같습니다.

- 200 OK
- 201 Created
- 202 Accepted
- 204 No Content

각각에 대해 살펴보도록 하겠습니다.

### 6.2.1. 200 OK

클라이언트에서 들어온 요청이 **잘 처리되었다**는 의미로 `200 OK`를 반환합니다.
실무에서 가장 많이 사용합니다.

### 6.2.2. 201 Created

클라이언트에서 들어온 요청을 통해 **새로운 리소스가 생성**되었다는 의미로 `201 Created`를 반환합니다.

<img width="358" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/f0dc7d4e-a5d9-4835-959f-1695d71222c2">

### 6.2.3. 202 Accepted

클라이언트에서 들어온 요청이 **접수되었으나 아직 처리되지 않았다**는 의미로 `202 Accepted`를 반환합니다.
예를 들어, 요청 접수 후 1시간 뒤에 배치 프로세스 요청을 처리하는 **배치 처리** 같은 곳에서 사용할 수 있습니다.
그러나 실제로는 실무에서 잘 사용하지 않습니다.

<img width="359" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/efd53eac-04cd-44de-9cd3-d072869759c6">

### 6.2.4. 204 No Content

클라이언트에서 들어온 요청을 **서버가 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없는 경우** `204 No Content`를 반환합니다.
예를 들어, 웹 문서 편집기에서 save 버튼을 눌렀을 때 응답으로 내려줄 수 있습니다.
왜냐하면, save 버튼의 결과로 아무 내용이 없어도 되며 같은 화면을 유지해야 하기 때문입니다.

## 6.3. 3xx - 리다이렉션

3xx는 요청을 완료하기 위해 유저 에이전트의 추가 조치가 필요하다는 의미이며, 대표적인 3xx 요청은 다음과 같습니다.

- 300 Multiple Choices
- 301 Moved Permanently
- 302 Found
- 303 See Other
- 304 Not Modified
- 307 Temporary Redirect
- 308 Permanent Redirect

### 6.3.1. 리다이렉션 이해

웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동으로 이동하는데 이를 **리다이렉트**라고 합니다.

`/event`라는 URI가 `/new-event`로 변경되었을 때에 대한 **자동 리다이렉트 흐름**은 다음과 같습니다.

<img width="348" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/e33fcbb9-bd1c-48cb-8bff-45dac697df64">

이러한 리다이렉션은 다음과 같이 3가지 종류가 있습니다.

1. 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동 (e.g. `/event` → `/new-event`)
2. 일시 리다이렉션 : 일시적인 변경 (e.g. 주문 완료 후 주문 내역 화면으로 이동)
3. 특수 리다이렉션 : 특수 리다이렉션 (결과 대신 캐시 사용)

### 6.3.2. 영구 리다이렉션

영구 리다이렉션은 **리소스의 URI가 영구적으로 이동**했음을 알려줍니다.
원래 URL을 사용하면 안되며, 검색 엔진 등에서 변경을 인지하여 URL을 바꿉니다.
이러한 영구 리다이렉션 상태 코드는 **301**과 **308**이 있습니다.

`301 Moved Permanently`은 리다이렉트 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있습니다.

<img width="430" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/dfddf8ef-b163-4a98-9d0a-faeb84227c17">

`308 Permanent Redirect`는 리다이렉트 시 요청 메서드와 본문을 유지합니다. 즉, POST를 보내면 리다이렉트도 POST를 유지합니다.

<img width="430" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/8e625586-58d0-48f3-a438-95a33cd8bda3">

### 6.3.3. 일시적인 리다이렉션

일시적인 리다이렉션은 **리소스의 URI가 일시적으로 변경**되는 것이며, 검색 엔진 등에서 리다이렉션이 와도 URL을 변경하면 안됩니다.
일시적인 리다이렉션의 종류는 다음과 같이 세 가지입니다.

- 302 Found
  - 리다이렉트 시 요청 메서드가 GET으로 변하고, 본문이 제거될 수도 있음
- 307 Temporary Redirect
  - 리다이렉트 시 요청 메서드와 본문을 유지
- 303 See Other
  - 리다이렉트 시 요청 메서드가 GET으로 변함

이러한 일시적인 리다이렉션이 꼭 필요한 상황은 언제일까요?

POST로 주문 후 웹 브라우저를 새로고침하는 상황을 살펴봅시다.
만약 새로고침이 되면, POST를 다시 요청하여 중복 주문이 발생할 수 있습니다.

<img width="501" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/ac1ad85b-7ec4-4a9e-9381-b6a00d161c7f">

이러한 상황을 방지하기 위해 일시적인 리다이렉션을 사용하며, 이를 **PRG(Post/Redirect/Get)**이라고 부릅니다.
PRG를 적용하면, POST 주문 후 새로고침 시 결과 화면을 GET 메서드로 리다이렉트하여 중복 주문을 방지할 수 있습니다.
뿐만 아니라, 새로고침하지 않아도 주문 후 주문 결과 화면을 GET 메서드로 리다이렉트 합니다.

<img width="573" alt="image" src="https://github.com/Kim-SuBin/TIL/assets/46712693/789ea94b-7712-4934-a2ad-5375390dc265">

그렇다면 **302, 307, 303 중 어떤 것을 쓰는 게 좋을까요??**

302는 GET으로 변할 수 있고, 307은 메서드가 변하면 안되며, 303은 메서드가 GET으로 변경됩니다.

처음 302 스펙의 의도는 HTTP 메서드를 유지하는 것이었는데, 웹 브라우저 대부분이 GET으로 바꾸어버렸습니다.
그래서 모호한 302를 대신하는 명확한 307, 303이 등장한 것입니다.

**307, 303을 권장**하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본 값으로 사용하며,
자동 리다이렉션 시에 GET으로 변해도 되면 그냥 302를 사용해도 큰 문제 없습니다.

### 6.3.3. 기타 리다이렉션

`300 Multiple Choices`는 잘 사용하지 않기에 넘어가도록 하겠습니다.

`304 Not Modified`는 **캐시를 목적으로 사용**합니다.
클라이언트에게 리소스가 수정되지 않았음을 알려주며, 클라이언트는 로컬 PC에 저장된 캐시를 재사용합니다.
그렇기에 304 응답은 메시지 바디를 포함하면 됩니다. 보통 조건부 GET, HEAD 요청 시 사용합니다.

## 6.4. 4xx - 클라이언트 오류

4xx는 **클라이언트의 요청에 잘못된 문법 등으로 서버가 요청을 수행할 수 없을 때** 사용합니다.
즉, **오류의 원인이 클라이언트에 있습니다.**
그렇기에 클라이언트가 똑같은 요청을 계속 재시도해도 이미 잘못된 요청으로 데이터를 보내기 때문에 실패합니다.
이러한 클라이언트 오류 상태 코드는 **400, 401, 403, 404**가 있습니다.

`400 Bad Request`는 클라이언트가 **잘못된 요청**을 해서 서버가 요청을 처리할 수 없음을 의미합니다.
예를 들어, 요청 파라미터가 잘못되거나 API 스펙이 맞지 않을 때 발생하며, 클라이언트에서 **요청 내용을 다시 검토하고 보내야 합니다.**

`401 Unauthorized`는 클라이언트가 **해당 리소스에 대한 인증이 필요하다**는 의미입니다.
즉, 인증(Authentication)이 되지 않아 발생하며, 401 오류 발생 시 응답에 `WWW-Authenticate` 헤더와 함께 인증 방법을 설명해주어야 합니다.

여기서 인증과 인가에 대해 짧게 살펴보겠습니다.

- 인증(Authentication) : 본인이 누구인지 확인 ☞ 로그인
- 인가(Authorization) : 권한 부여가 필요함 ☞ Admin 권한처럼 특정 리소스에 접근할 수 있는 권한

인가는 인증이 있어야 존재할 수 있습니다.
여기서 401 이름이 `Unauthorized`로 되어 있어 헷갈릴 수 있는데, 401은 인증이 되지 않음을 나타내는 것이 맞습니다. (헷갈리지 않게 주의해주세요!)

`403 Forbidden`은 서버가 요청을 이해했지만 **승인을 거부**했다는 의미입니다.
어드민 등급이 아닌 사용자가 어드민 등급 리소스에 접근하는 등, 주로 **인증 자격은 있지만, 접근 권한이 불충분**한 경우 발생합니다.

`404 Not Found`는 **요청 리소스를 찾을 수 없다**는 의미입니다.
요청 리소스가 서버에 없거나 클라이언트가 권한이 부족한 리소스에 접근했을 때 해당 리소스를 숨기고 싶은 경우 사용합니다.

## 6.5. 5xx - 서버 오류

5xx는 말 그대로 **서버 문제로 오류가 발생했음**을 의미하며, 서버에서 문제가 해결되면 클라이언트에서 요청을 재시도 했을 때 성공을 반환합니다.

`500 Internal Server Error`는 **서버 내부 문제**로 오류가 발생한 것을 의미하며, 진짜 서버에 문제가 있는 경우에만 500 상태 코드를 내려줄 수 있도록 구현해야 합니다.
예를 들어, 고객의 잔고 부족으로 예금 출금을 할 수 없어 에러가 발생했다고 합시다. 이런 경우 500 에러가 아닌 다른 상태 코드를 통해 잔고가 부족함을 알려주어야 합니다.
이렇듯 비즈니스적인 이슈로 발생하는 예외 상황은 500을 최대한 사용하지 않아야 크리티컬한 이슈가 무엇인지 파악할 수 있습니다.

`503 Service Unavaliable`는 서버가 일시적인 과부하나 예정된 작업으로 잠시 요청을 처리할 수 없는 등 **서비스를 이용할 수 없는 경우** 사용합니다.
Retry-After 헤더 필드로 얼마 뒤에 복구되는지도 보낼 수 있습니다.

> 본 게시글은 [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard) 강의를 참고하여 작성되었습니다.
>
> 상세한 내용이 궁금하시다면 강의 수강을 추천해 드립니다.
